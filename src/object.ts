export {};

//objectを扱う時は色々とあるが今回は触りの部分詳しくは後ほど。
//let profile1 = { name: 'Ham'}
//これに対してどうゆうアノテーションをすることができるのか。
let profile1: object = { name: 'Ham'};　
//これが一番単純なもの。オブジェクト全般を扱うことができる。
profile1 = {birthYear: 1976};//異なるプロパティを再代入して上書きしても、問題は起きない。
//objectは制約が甘い。 profile1に変数を用いて想定外の型に変わった時にそれに気づくことがエラーが発生できないのでできない。のがデメリット。
//デメリットを解決するにはどうするのか。
//let profile2: {} = {name: 'Ham'};
//{}もアノテーションの方法
//pfofile2 = {birthYear: 1976};
//を再代入してもエラーが起きない。　objectを指定した時となんら変わらない。同じ様なアノテーションをすることはできるが、制約が甘いのでリスクはある。
//object と{}の違いは{}はプロパティについても型指定をすることができるという拡張性を持っている。　
//let profile2 = {name: 'Ham'};//型推論ではname: stringと推論されている。これをアノテーションとして書くことができる。
let profile2: {
  name: string;
} = { name: 'Ham'};
//{}だと漠然と型を指定するだけではなく、objectのプロパティについても、型のアノテーションを指定することができる。nameという属性が必ず存在し、その型を宣言することができる。
//profile2 = {birthYear: 1976};
//アノテーションの中以外で宣言されていないプロパティについてはきちんとエラーを表示してくれる。
//アノテーションで指定したものを入れるしかないようになる。
profile2 = {name: 'Nimo'};
//アノテーションで指定をしたものを再代入時に指定してあげることで、その値を上書きすることができる。
//型宣言は制約が出来るだけ強くなることが理想的。想定外のものを防ぐことができるから。
