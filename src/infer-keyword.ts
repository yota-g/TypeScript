export {};

function add(a: number, b: number ){
  return a + b ;
};
console.log(add(1,2));

type ReturnTypeFromAdd = ReturnType<typeof add>;
//ReturnTypeの定義を確認してコピーして、貼り付ける。
//名前を変更していく。標準のものと同じ名前はまずいから。
//ReturnTypeに指定できる型は制約がある。 (...args: any) => any　...argsは引数なんでもいいよ。　
//実質関数を意味している。Tには関数の型である事が制約として存在している。
type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
  ) => infer R 
  ? R 
  : any;
//?は=の前は条件で真だったらRが得られる、偽だとanyが得られるというconditional typesが使用されている。
//この中で見慣れない新キャラはinferは条件を記載する部分に書く事ができる特殊なキーワード。
//inferは条件の一部としてgenerics型を宣言できるようになるという役割を持っている。
//通常generics型の特徴は<>を使用して書くのが通常。
//<>で認知された型は今回Tという変数でその型で再利用できる。
//いろんなところでTの再利用ができる。何でそうするのか型を定義した時点ではどんな型を使うのかを抽象化している。　
//抽象化して、どんな型を使うのかは使うユーザーに指定させている。委ねている。
//その型を型の定義の中で再利用したいから。<>方式の指定の仕方は型の名前の直後人しかかけない。
// Conditional Typesでは無数のパターンの条件式をかける。その条件式の中で型を拾い上げたい場面がある。　
// =>の右側の戻り値の型をどんな型かわからないけどそこの型をピックアップしたい。制御指定というのがinfer R
//戻り値の型がRとして扱われる。
//T extends (...args: any) => anyとT extends (...args: any ) => infer R は全く同じ。
//つまり、MyReturnTypeが使われた時に、関数である事が約束されているので、条件式の評価の結果も常に真になる。
//クエスチョンの後ろで採用されるのは絶対R
//すなわち戻り値の型が得られる。 infefは推論という意味。型として推論した結果をR に代入する。
//inferは重要なキーワード


