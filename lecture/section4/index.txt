Section4
37. クラスを作ってみよう。
新しいセクション　クラスで型を使用する。
classを使ってみることをしてみる。
クラスを使用してtsを使用してみよう。
echo 'export {}'  > src/my-first-class.tsのファイルを使用。

38,アクセス修飾子を使ってみよう。
ts独自の使用
一般的にはオブジェクト指向言語にはお馴染み。
クラスのメンバーに対して、パブリック、プライベート、プロテクテットを使用してアクセスできるできないを設定していく。
cp src/my-first-class.ts src/access-modifers.ts で前回のファイルをコピーして使用していく。

access-modifiers.tsというファイルを作成。

39.constructorを使い倒す
tsにおけるconstructor機能の裏技を使用
echo 'export {}'  > src/more-constructor.ts
で作業をする。

40.getterとsetter 
アクセサーという機能。オブジェクト指向プログラミングの鉄板機能
echo 'export {}'  > src/gettr-and-setter.tsでやっていく

41.readonly修飾子
echo 'export {}'  > src/readonly.ts
というファイル名を作成して実施していく。
クラスのプロパティを読み取り専用にする時に利用するもの。

42.静的メンバを定義しよう
echo 'export {}'  > src/staticmember.tsのファイルを作成。
クラスのセクション後半戦
オブジェクトでお馴染みの静的メンバを定義する。
静的メンバとは、クラスを使用してコーディングをすると少なくともクラスからインスタンス、インスタンスからアクセスできるメンバを使用して、属性を参照してきた。これらは具体的にnewでオブジェクト毎に持つ個々のメンバーを作れた。
newと引数を渡してコンストラクターに初期化をさせて各オブジェクトにまちまちなメンバーを持たせる事ができた。
それぞれのメンバーがユニークなメンバーだった。
これに対して、いつも決まったメンバーを持たせたいクラス設定。
newによってわざわざ作らずとも、そのメンバーにアクセスしたい時に利用できるのが静的メンバ

43.namespaceによる名前空間
プログラミングの独特な概念
どんなプログラミングにもある。
同一空間に同一のファイルを作る事ができない。
けど、別フォルダには作成できる。
つく場所が異なればいける。
名前空間はフォルダ名と同じ。
ファイルとを作っていく。
echo 'export {}'  > src/namespaces.tsでやっていく。

44.継承について、
クラスについてやってきたので、継承について学習していく。
継承とは既存のクラスを拡張して新たなクラスを作り上げる事。
拡張の仕方を学ぶ。
echo 'export {}'  > src/inheritance.tsというファイルで実施していく。

45.抽象クラスと抽象メソッド
object思考機能の前提知識
抽象メソッドは必ずオーバーライドするもの
処理の実態がないから。
このクラスにはこのような処理のメソッドがあるよという宣言のみ。
抽象メソッドの宣言のことをシグネチャーという。
echo 'export {}'  > src/abstract-classes.ts　でファイルを作成して、作業を実施していく。

46,インターフェース・リターンズ
23.interfaceの続き。tsのinterfaceには他の機能がある。
これから紹介する機能の方がポピュラーなもの。
classの概念を利用して、interfaceを使用する。
echo 'export {}'  > src/return-of-interfaces.tsでファイルを作成で実施。　

returnを使用する事でfunction外にその値を出力する事が可能になる。
returnがないと外から参照する事ができない。
参照する必要がないならvoidなどでundefindを表示させないようにできる。

例。
function mensekii(r) {
  let i = 3.14 * r * r
  console.log(i);
  return i;
}

let mm = menseki(7)
cosole.log(mm);
この場合関数の中のconsole.log(l)は独自で出力する。だが、外部からの呼び出しでは表示されない。
でもreturnの後につけたiは外部の変数mmを利用し他のものに代入したり、consolo.log()を外部で使用して表示する事ができる。
returnがないと関数の外部では参照できないのが判明。



